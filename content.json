{"meta":{"title":["做好一件事"],"subtitle":null,"description":"一个人，一件事，一辈子...","author":"黄磊","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-01-19T04:24:52.000Z","updated":"2017-01-19T06:47:23.960Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我黄磊 安徽涡阳人，现居于上海黄浦 一个致力于成为Java后台开发工程师的Android程序员 爱学习｜爱技术｜爱生活｜篮球｜音乐｜读书 联系我QQ：1519611483 Email：huanglei365@163.com Github：github.com/huanglei365"},{"title":"","date":"2017-01-19T03:50:43.000Z","updated":"2017-01-19T05:36:27.602Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-19T03:43:52.000Z","updated":"2017-01-19T05:35:52.013Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"带你彻底理解java中的==、equal、hashCode","slug":"带你彻底理解java中的-、equal、hashCode","date":"2017-01-24T01:29:49.000Z","updated":"2017-01-24T06:34:15.365Z","comments":true,"path":"2017/01/24/带你彻底理解java中的-、equal、hashCode/","link":"","permalink":"http://yoursite.com/2017/01/24/带你彻底理解java中的-、equal、hashCode/","excerpt":"相信很多刚入门的甚至有Java开发工程师对==、equals和为什么重写equal方法一定要重写hashCode方法都有很多的疑惑，今天就带你彻底理解==和equals的区别以及重写hashCode方法的意义！ ==的含义Java官网教程对==的描述如下： Checks if the values of two operands are equal or not, if yes then condition becomes true. ==是一个二元操作符，比较两个操作数是否相等！现在的关键就是理解操作数，下面我们通过一个例子说明一下不同类型的操作数的比较结果：","text":"相信很多刚入门的甚至有Java开发工程师对==、equals和为什么重写equal方法一定要重写hashCode方法都有很多的疑惑，今天就带你彻底理解==和equals的区别以及重写hashCode方法的意义！ ==的含义Java官网教程对==的描述如下： Checks if the values of two operands are equal or not, if yes then condition becomes true. ==是一个二元操作符，比较两个操作数是否相等！现在的关键就是理解操作数，下面我们通过一个例子说明一下不同类型的操作数的比较结果：123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // 基本数据类型 int a = 1, b = 1; System.out.println(a == b); // 基本类型的包装类型（属于引用） Integer aS = 1, bS = 1; System.out.println(aS == bS); Integer aB = 234, bB = 234; System.out.println(aB == bB); // 引用类型 Test testa = new Test(); Test testb = new Test(); System.out.println(testa == testb); &#125; public static class Test &#123; &#125; /*输出结果如下： * true * true * false * false */ 关于输出结果，现在很多人可能还在疑惑，那我们就给大家解释一下为什么是上面的输出结果！==的含义是比较两个操作数的Memory Refrence，翻译过来就是内存引用，即当前对象对应的内存地址比较(可以这么理解)！我们知道1.基本类型变量和对象的引用变量都在函数的栈内存中分配，注意栈有一个很重要的特殊性，就是存在栈中的数据可以共享，2.new创建的对象和数组以及对象的实例变量！想了解更多请参见java内存类型及不同数据类型的存储，有了这样的知识上面的结果是不是就好理解一点！第一行输出我们可能都可以理解，共享了同一个数据，但是第二行和第三行就疑惑了？为啥输出结果不相同呢？原因是Integer使用了缓存机制(-128-127都是同一个对象，除非手动new对象，想了解更多请参见java Integer类的缓存)，关于最后一行输出结果应该也很容易理解(testa,testb不是同一个对象)！我们可以使用System.identityHashCode()(此方法返回Object.hashCode，无论有没有重写hashCode方法)方法进行hash验证！ equals的理解以及重写规则网上的说法一般都是说equals比较的是内容，那我们该如何理解内容的含义呐！下面我们从源码的角度更深入的理解！想要理解equals方法，必须知道在哪里实现了这个方法！我们知道，equals方法是Object对象的方法，Object对象默认是所有对象的父类，可以被其子类重写！那我们现看一下Object是如何实现的，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Indicates whether some other object is &quot;equal to&quot; this one. * &lt;p&gt; * The &#123;@code equals&#125; method implements an equivalence relation * on non-null object references: * &lt;ul&gt; * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value * &#123;@code x&#125;, &#123;@code x.equals(x)&#125; should return * &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, &#123;@code x.equals(y)&#125; * should return &#123;@code true&#125; if and only if * &#123;@code y.equals(x)&#125; returns &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125;, &#123;@code y&#125;, and &#123;@code z&#125;, if * &#123;@code x.equals(y)&#125; returns &#123;@code true&#125; and * &#123;@code y.equals(z)&#125; returns &#123;@code true&#125;, then * &#123;@code x.equals(z)&#125; should return &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, multiple invocations of * &#123;@code x.equals(y)&#125; consistently return &#123;@code true&#125; * or consistently return &#123;@code false&#125;, provided no * information used in &#123;@code equals&#125; comparisons on the * objects is modified. * &lt;li&gt;For any non-null reference value &#123;@code x&#125;, * &#123;@code x.equals(null)&#125; should return &#123;@code false&#125;. * &lt;/ul&gt; * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) &#123; return (this == obj); &#125; 从源码可知，如果子类没有重写equals方法，那么equals和==号的含义一样！那如果我们重写了方法就代表我们定义了一组代表两个对象相等的规则！这样是不是就代表我们就可以随意定义规则了呢？当然了，如果你想这样做也可以(不考虑各种后果，请自行百度)！系统建议我们重写equals必须满足一定的规则，并且必要的话，要重写hashCode方法，否则两个等价对象可能得到不同的hashCode,这在集合框架中使用可能产生严重后果！一般重写equals需要满足以下规则： 1．自反性：对于任意的非空引用值x，x.equals(x)一定为true 2． 对称性：对于任意的引用值x 和 y，当x.equals(y)返回true，y.equals(x)也一定返回true3． 传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也一定返 回 true 4． 一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修改， 多次调用x.equals(y)要么一致地返回true，要么一致地返回false5． 非空性：对于任意的非空引用值x，x.equals(null)一定返回false下面是重写equal的一个例子，大家可以思考下面的写法是怎么满足以上５个条件的： 1234567891011121314151617181920212223242526272829303132333435363738public class Book &#123; private String name; private int price; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; @Override public boolean equals(Object o) &#123; if (o == null || !(o instanceof Book)) &#123; return false; &#125; if (getName() != null &amp;&amp; getName().equals(((Book) o).getName()) &amp;&amp; getPrice() == ((Book) o).getPrice()) &#123; return true; &#125; return super.equals(o); &#125; @Override public int hashCode() &#123; int hashCode = getName() == null ? 0 : getName().hashCode(); return hashCode + price; &#125; &#125; 关于重写hashCode函数的意义上面我们已经强调了如果有必要一定要重写hashCode但没有说明原因，这一节我们就通过源码来深入理解hashCode的意义！Java中的集合（Collection）有两类，一类是List，再有一类是Set．你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复．那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了．也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率．于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了．哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。如果详细讲解哈希算法，那需要更多的文章篇幅，我在这里就不介绍了。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）．这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上．如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址．所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。所以，Java对于eqauls方法和hashCode方法是这样规定的：1、如果两个对象相同，那么它们的hashCode值一定要相同；2、如果两个对象的hashCode相同，它们并不一定相同上面说的对象相同指的是用eqauls方法比较。通过以上我们可以知道，重写hashCode方法，让相同的对象hash值相同，不同对象hash值不同(减少hash冲突)，这样可以大大的提高Java中使用hash表实现的数据结构的插入和查找效率！ 总结==：比较两个对象的内存地址是否一样equals：通过自定义规则，比较两个对象的内容是否相等hashCode：重写equals时，之所以要重写次此方法，主要是为了与equals保持相同的结果，进而减少hash冲突，提高hash表的插入和查找效率！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Equal","slug":"Equal","permalink":"http://yoursite.com/tags/Equal/"},{"name":"Hash","slug":"Hash","permalink":"http://yoursite.com/tags/Hash/"}]},{"title":"Android WebView Cookie机制详解","slug":"Android-WebView-Cookie机制详解","date":"2017-01-23T09:18:03.000Z","updated":"2017-01-24T02:50:28.715Z","comments":true,"path":"2017/01/23/Android-WebView-Cookie机制详解/","link":"","permalink":"http://yoursite.com/2017/01/23/Android-WebView-Cookie机制详解/","excerpt":"随着H5在移动端的体验越来越好，越来越多的Android App开始采用Native+H5进行混合开发！极大的提高了开发效率！最近公司在做一个新闻阅读的模块，由于我们没有资源，所以选择了第三方Url接入方式．在开发的过程中，需要用到WebView Cookie的设置！下面详细的说明WebView Cookie机制．","text":"随着H5在移动端的体验越来越好，越来越多的Android App开始采用Native+H5进行混合开发！极大的提高了开发效率！最近公司在做一个新闻阅读的模块，由于我们没有资源，所以选择了第三方Url接入方式．在开发的过程中，需要用到WebView Cookie的设置！下面详细的说明WebView Cookie机制． Cookie机制? 众所周知，HTTP协议是一种无状态的协议，一旦数据交换完成，客户端与服务端的连接就会关闭，如果需要再次交换数据，就需要再次联立连接，导致服务端无法跟踪上次的会话！Cookie机制是一种会话跟踪的技术，通过在客户端记录信息用以确定用户身份！ Cookie其实就是服务器用于确认客户端身份给客户端的信息，下次客户端请求时带上Cookie信息，服务器就可以根据Cookie确定用户信息进而进行个性化处理！ Cookie的属性包括Key，Value，MaxAge，Path等等，关于具体的属性信息请参考：[Android HttpCookie信息][1] 注意：为了保证用户的信息安全，Cookie是不可跨域名的！Cookie在客户端是由浏览器管理的，访问baidu.com的域名不会携带google.com的Cookie! 如何给Android中的WebView设置Cookie信息？ 涉及到的主要类及介绍其中主要涉及到CookieSyncManager和CookieManager两个类！CookieSyncManager：顾名思义就是浏览器Cookie在内存和永久性存储器之间的同步类（The CookieSyncManager is used to synchronize the browser cookie store between RAM and permanent storage），其中包括startSync(),stopSync(),sync()(强制同步)等方法；（注意：Api 21已废除，通过CookieManager进行自动同步）CookieManager：管理WebView Cookie的类，其中包括setCookie(),getCookie()等等方法． 获取Cookie和给WebView设置Cookie获取Cookie比较简单，直接调用CookieManager.getInstance().getCookie(url)即可获得；设置Cookie在webView实例对象调用loadUrl方式之前调用如下函数即可． 1234567891011 public static void syncCookie(Context context, String url, HashMap&lt;String, String&gt; cookies) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); Iterator iterator = cookies.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); cookieManager.setCookie(url, entry.getValue() + &quot;=&quot; + entry.getKey()); &#125;&#125; 使用场景主要使用在，服务端需要客户端的数据以确定客户身份的情况！比如：登录同步(我们通过HttpUrlConnection获得的Cookie设置给WebView就可以实现登录同步了)等等，还有许多应用需要你去发掘…","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"WebView","slug":"WebView","permalink":"http://yoursite.com/tags/WebView/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"}]},{"title":"ubuntu上构建简单的基于http的文件共享服务","slug":"ubuntu上构建简单的基于http的文件共享服务","date":"2017-01-23T03:41:49.000Z","updated":"2017-01-24T02:50:33.451Z","comments":true,"path":"2017/01/23/ubuntu上构建简单的基于http的文件共享服务/","link":"","permalink":"http://yoursite.com/2017/01/23/ubuntu上构建简单的基于http的文件共享服务/","excerpt":"下面的方法教你如何用简单的几行命令就可以在ubuntu上构建一个http文件共享服务。 首先，你需要安装一个脚本，你只要执行以下指令即可：","text":"下面的方法教你如何用简单的几行命令就可以在ubuntu上构建一个http文件共享服务。 首先，你需要安装一个脚本，你只要执行以下指令即可： 1．下载脚本文件： sudo wget -O /usr/local/bin/subdirs http://github.com/singpolyma/singpolyma/raw/master/scripts/subdirs 2．给脚本文件增加执行权限： sudo chmod +X /usr/local/bin/subdirs３．然后，你需要安装wefs http server，执行以下指令即可install： sudo apt-get install webfs４．最后，你只要简单的配置一下，简单的http文件共享服务就构建完成了： 打开/etc/webfsd.conf文件并编辑配置web_root、web_port，我相信大家都知道这两个的含义。 现在，我们的http服务已经构建完成，就让我们开始使用吧。1.重启wefs 服务：sudo /etc/init.d/wefs restart2.在浏览器中输入：http://www.{your ip address:port}.com/，开始访问吧！","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/categories/Ubuntu/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":" android 跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果","slug":"android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果","date":"2017-01-23T02:38:59.000Z","updated":"2017-01-24T02:50:30.731Z","comments":true,"path":"2017/01/23/android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果/","link":"","permalink":"http://yoursite.com/2017/01/23/android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果/","excerpt":"前言 我相信很多人都在实现过Android的跑马灯效果，肯定也有很多人说一个界面不能实现多个跑马灯效果，其实我们通过很简单的方式就可以实现，下面介绍一个实现方式。 单个跑马灯实现","text":"前言 我相信很多人都在实现过Android的跑马灯效果，肯定也有很多人说一个界面不能实现多个跑马灯效果，其实我们通过很简单的方式就可以实现，下面介绍一个实现方式。 单个跑马灯实现 1234567891011&lt;TextView android:layout_width=\"100px\" android:layout_height=\"wrap_content\" android:ellipsize=\"marquee\" android:focusable=\"true\" android:singleLine=\"true\" android:marqueeRepeatLimit=\"marquee_forever\" android:focusableInTouchMode=\"true\" android:scrollHorizontally=\"true\" android:text=\"马灯效果\"&gt; &lt;/TextView&gt; 备注： ellipsize=”marquee” :跑马灯效果 marqueeRepeatLimit:循环的次数 singleLine:如果不设置成单行，跑马灯也就没有了意义 至于为什么focusable设置为true，那是因为只有获得了焦点才能出现跑马灯的效果 更多的含义请参跑马灯效果的总结 一个界面多个跑马灯效果实现 想要实现一个界面多个跑马灯，就要现了解系统是如何实现以及在什么情况下会显示跑马灯效果．我们在TextView中发现以下源码（Api 23）： 12345678910111213141516171819202122232425private void startMarquee() &#123; // Do not ellipsize EditText if (getKeyListener() != null) return; if (compressText(getWidth() - getCompoundPaddingLeft() - getCompoundPaddingRight())) &#123; return; &#125; if ((mMarquee == null || mMarquee.isStopped()) &amp;&amp; (isFocused() || isSelected()) &amp;&amp; getLineCount() == 1 &amp;&amp; canMarquee()) &#123; if (mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123; mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_FADE; final Layout tmp = mLayout; mLayout = mSavedMarqueeModeLayout; mSavedMarqueeModeLayout = tmp; setHorizontalFadingEdgeEnabled(true); requestLayout(); invalidate(); &#125; if (mMarquee == null) mMarquee = new Marquee(this); mMarquee.start(mMarqueeRepeatLimit); &#125; &#125; 由源代码（isFocused() || isSelected()）可知只有当TextView拥有焦点或者是选中状态是才会有跑马灯效果，但是Android的焦点机制只能有一个View获得焦点．我们怎么才能让多个View处于获得焦点或者被选中状态呢？我们可以通过重写TextView的isFocused()或者isSelected()方法来告诉系统此View已经获得焦点！下面是代码实现： import android.content.Context;import android.text.TextUtils;import android.util.AttributeSet;import android.widget.TextView; 12345678910111213141516171819202122232425262728293031323334353637public class MarqueeTextView extends TextView &#123; public MarqueeTextView(Context context) &#123; this(context, null); &#125; public MarqueeTextView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MarqueeTextView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; setEllipsize(TextUtils.TruncateAt.MARQUEE); setMarqueeRepeatLimit(-1); setSingleLine(); &#125; /* * 不建议重写isFocused()方法． * 经过测试发现如果有多个跑马灯效果的界面还有EditText,在某些机型上会由于焦点问题弹出输入法键盘． */ /* @Override public boolean isFocused() &#123; return true; &#125;*/ @Override public boolean isSelected() &#123; return true; &#125;&#125; 用法只要在layout文件中添加如下代码：123&lt;＊.MarqueeTextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 用法也比以前简单了很多，不用如下乱七八糟的设置： 123456 android:focusable android:ellipsize=”marquee” android:focusable=”true” android:singleLine=”true” android:marqueeRepeatLimit=”marquee_forever” android:focusableInTouchMode=”true” 这样就完美的解决了我们的问题，是不是很简单？","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"TextView","slug":"TextView","permalink":"http://yoursite.com/tags/TextView/"},{"name":"Marquee","slug":"Marquee","permalink":"http://yoursite.com/tags/Marquee/"}]}]}