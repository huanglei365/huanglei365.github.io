{"meta":{"title":["做好一件事"],"subtitle":null,"description":"一个人，一件事，一辈子...","author":"黄磊","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-01-19T04:24:52.000Z","updated":"2017-01-19T06:47:23.960Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我黄磊 安徽涡阳人，现居于上海黄浦 一个致力于成为Java后台开发工程师的Android程序员 爱学习｜爱技术｜爱生活｜篮球｜音乐｜读书 联系我QQ：1519611483 Email：huanglei365@163.com Github：github.com/huanglei365"},{"title":"","date":"2017-01-19T03:50:43.000Z","updated":"2017-01-19T05:36:27.602Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-19T03:43:52.000Z","updated":"2017-01-19T05:35:52.013Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":" android 跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果","slug":"android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果","date":"2017-01-23T02:38:59.000Z","updated":"2017-01-23T03:40:29.150Z","comments":true,"path":"2017/01/23/android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果/","link":"","permalink":"http://yoursite.com/2017/01/23/android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果/","excerpt":"","text":"前言 我相信很多人都在实现过Android的跑马灯效果，肯定也有很多人说一个界面不能实现多个跑马灯效果，其实我们通过很简单的方式就可以实现，下面介绍一个实现方式。 单个跑马灯实现1234567891011&lt;TextView android:layout_width=\"100px\" android:layout_height=\"wrap_content\" android:ellipsize=\"marquee\" android:focusable=\"true\" android:singleLine=\"true\" android:marqueeRepeatLimit=\"marquee_forever\" android:focusableInTouchMode=\"true\" android:scrollHorizontally=\"true\" android:text=\"马灯效果\"&gt; &lt;/TextView&gt; 备注： ellipsize=”marquee” :跑马灯效果 marqueeRepeatLimit:循环的次数 singleLine:如果不设置成单行，跑马灯也就没有了意义 至于为什么focusable设置为true，那是因为只有获得了焦点才能出现跑马灯的效果 更多的含义请参跑马灯效果的总结 一个界面多个跑马灯效果实现 想要实现一个界面多个跑马灯，就要现了解系统是如何实现以及在什么情况下会显示跑马灯效果．我们在TextView中发现以下源码（Api 23）： 12345678910111213141516171819202122232425private void startMarquee() &#123; // Do not ellipsize EditText if (getKeyListener() != null) return; if (compressText(getWidth() - getCompoundPaddingLeft() - getCompoundPaddingRight())) &#123; return; &#125; if ((mMarquee == null || mMarquee.isStopped()) &amp;&amp; (isFocused() || isSelected()) &amp;&amp; getLineCount() == 1 &amp;&amp; canMarquee()) &#123; if (mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123; mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_FADE; final Layout tmp = mLayout; mLayout = mSavedMarqueeModeLayout; mSavedMarqueeModeLayout = tmp; setHorizontalFadingEdgeEnabled(true); requestLayout(); invalidate(); &#125; if (mMarquee == null) mMarquee = new Marquee(this); mMarquee.start(mMarqueeRepeatLimit); &#125; &#125; 由源代码（isFocused() || isSelected()）可知只有当TextView拥有焦点或者是选中状态是才会有跑马灯效果，但是Android的焦点机制只能有一个View获得焦点．我们怎么才能让多个View处于获得焦点或者被选中状态呢？我们可以通过重写TextView的isFocused()或者isSelected()方法来告诉系统此View已经获得焦点！下面是代码实现： import android.content.Context;import android.text.TextUtils;import android.util.AttributeSet;import android.widget.TextView; 12345678910111213141516171819202122232425262728293031323334353637public class MarqueeTextView extends TextView &#123; public MarqueeTextView(Context context) &#123; this(context, null); &#125; public MarqueeTextView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MarqueeTextView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; setEllipsize(TextUtils.TruncateAt.MARQUEE); setMarqueeRepeatLimit(-1); setSingleLine(); &#125; /* * 不建议重写isFocused()方法． * 经过测试发现如果有多个跑马灯效果的界面还有EditText,在某些机型上会由于焦点问题弹出输入法键盘． */ /* @Override public boolean isFocused() &#123; return true; &#125;*/ @Override public boolean isSelected() &#123; return true; &#125;&#125; 用法只要在layout文件中添加如下代码：123&lt;＊.MarqueeTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 用法也比以前简单了很多，不用如下乱七八糟的设置： 123456 android:focusable android:ellipsize=”marquee” android:focusable=”true” android:singleLine=”true” android:marqueeRepeatLimit=”marquee_forever” android:focusableInTouchMode=”true” 这样就完美的解决了我们的问题，是不是很简单？","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"TextView","slug":"TextView","permalink":"http://yoursite.com/tags/TextView/"},{"name":"跑马灯","slug":"跑马灯","permalink":"http://yoursite.com/tags/跑马灯/"}]}]}