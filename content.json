{"meta":{"title":["做好一件事"],"subtitle":null,"description":"一个人，一件事，一辈子...","author":"黄磊","url":"http://huanglei365.com"},"pages":[{"title":"","date":"2017-01-19T04:24:52.000Z","updated":"2017-01-19T06:47:23.960Z","comments":true,"path":"about/index.html","permalink":"http://huanglei365.com/about/index.html","excerpt":"","text":"关于我黄磊 安徽涡阳人，现居于上海黄浦 一个致力于成为Java后台开发工程师的Android程序员 爱学习｜爱技术｜爱生活｜篮球｜音乐｜读书 联系我QQ：1519611483 Email：huanglei365@163.com Github：github.com/huanglei365"},{"title":"","date":"2017-01-19T03:50:43.000Z","updated":"2017-01-19T05:36:27.602Z","comments":false,"path":"categories/index.html","permalink":"http://huanglei365.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-19T03:43:52.000Z","updated":"2017-01-19T05:35:52.013Z","comments":false,"path":"tags/index.html","permalink":"http://huanglei365.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android热修复技能Andfix","slug":"android热修复技能Andfix","date":"2017-03-08T02:28:13.000Z","updated":"2017-03-08T10:17:27.344Z","comments":true,"path":"2017/03/08/android热修复技能Andfix/","link":"","permalink":"http://huanglei365.com/2017/03/08/android热修复技能Andfix/","excerpt":"很多小伙伴可能还在为一个紧急bug头痛，又要因为一行代码发新版本了，不仅仅浪费用户流量，还让用户感到我们的产品不靠谱，对双方都是一个损失！我们能不能避免这个损失呢？当然可以了，要不然我也不在这(bi)里(bi)了。我们的解决方案是热修复技术，接下来我们就详细的介绍下热修复技术在android中的使用，本文中使用的是阿里巴巴的热修复方案：Andfix！ 热修复和为何选择Andfix","text":"很多小伙伴可能还在为一个紧急bug头痛，又要因为一行代码发新版本了，不仅仅浪费用户流量，还让用户感到我们的产品不靠谱，对双方都是一个损失！我们能不能避免这个损失呢？当然可以了，要不然我也不在这(bi)里(bi)了。我们的解决方案是热修复技术，接下来我们就详细的介绍下热修复技术在android中的使用，本文中使用的是阿里巴巴的热修复方案：Andfix！ 热修复和为何选择Andfix 热修复：当线上应用出现紧急BUG，为了避免重新发版，并且保证修复的及时性而进行的一项在线推送补丁的修复方案。 当前业界比较热门的热修复方案好几种，比如腾讯QQ空间的超级补丁、微信的Tinker和阿里百川的Andfix，那么为何我们要选择Andfix呢？当然是基于Andfix的几个优点了，Andfix有以下几个优点让你无法抗拒： BUG修复的即时性 补丁包同样采用差量技术，生成的PATCH体积小 对应用无侵入，几乎无性能损耗 为了让大家对热修复方案有更加直观的比较，下面借用一张图来说明问题： 看完之后明白了吧，请放心的使用Andfix吧！ 快速集成Andfix添加依赖包对于Android studio开发者，gradle配置文件下添加以下依赖即可：123dependencies &#123; compile 'com.alipay.euler:andfix:0.4.0@aar'&#125; 建议大家使用0.4.0版本号，因为最新的0.5.0十分不稳定，bug很多！请参考Andfix issues对于Eclipse开发者，请自行解决！ 初始化PatchManager12patchManager = new PatchManager(context);patchManager.init(appversion);//当前打patch的版本号 关于appversion这个参数，可以使用versionCode+”-“+versionName+补丁的URL的MD5值作为关键字，这样同一个版本我们可以打多个补丁！另外每次打patch时记录appversion值，下次下载patch前，先判断patch是否已经打过，避免多次下载补丁（节省流量）！另外调用init时，如果当前appversion和以前打补丁的appversion不一样，PatchManager恵自动帮你clean掉以前已经加载的patch，所以不用担心patch文件会积累的问题！init(appversion)如下： 1234567891011121314151617public void init(String appVersion) &#123; if(!this.mPatchDir.exists() &amp;&amp; !this.mPatchDir.mkdirs()) &#123; Log.e(\"PatchManager\", \"patch dir create error.\"); &#125; else if(!this.mPatchDir.isDirectory()) &#123; this.mPatchDir.delete(); &#125; else &#123; SharedPreferences sp = this.mContext.getSharedPreferences(\"_andfix_\", 0); String ver = sp.getString(\"version\", (String)null); if(ver != null &amp;&amp; ver.equalsIgnoreCase(appVersion)) &#123; this.initPatchs(); &#125; else &#123; this.cleanPatch(); sp.edit().putString(\"version\", appVersion).commit(); &#125; &#125;&#125; 加载patch1patchManager.loadPatch(); 我们应该尽可能早的去加载patch，避免bug引起程序崩溃！建议在Application的onCreate方法时调用！注意：loadPatch()方法一定要在主线程中调用，在非主线程调用会引起崩溃，还会导致patch不能立即生效，只有重启应用才会生效！ 增加patch1patchManager.addPatch(path);//下载后patch的本地路径,不是patch的下载路径 调用此方法后，patch立即生效！注意请在主线程中调用。 关于patch生成和下载，请参考以下方案！patch生成阿里百川提供了工具，可以在两个apk间直接生成.apatch文件，apkpatch工具点击下载，关于工具的使用和参数的含义如下： 123456789usage: apkpatch -f &lt;new&gt; -t &lt;old&gt; -o &lt;output&gt; -k &lt;keystore&gt; -p &lt;***&gt; -a &lt;alias&gt; -e &lt;***&gt; -a,--alias &lt;alias&gt; keystore 别名. -e,--epassword &lt;***&gt; keystore entry 密码. -f,--from &lt;loc&gt; 修复bug后的apk路径. -k,--keystore &lt;loc&gt; keystore 路径. -n,--name &lt;name&gt; 生成patch的文件名. -o,--out &lt;dir&gt; 输出目录. -p,--kpassword &lt;***&gt; keystore 密码. -t,--to &lt;loc&gt; 存在bug的apk路径. 注意：工具里有apkpatch.sh和apkpatch.bat文件，分别供linux（mac）和windows使用，命令运行成功后，会在输出目录里生成.apatch的文件！这个文件就是我们app所用的patch文件！ 如何判断此版本需要打补丁，以及打哪个补丁？方案1：可以让后台提供一个接口：app通过传递版本信息，获得当前版本的patch信息，根据信息去下载相应的patch文件；方案2：可以通过在云服务器上上传一个.json的文件（文件名跟版本信息相关），文件内容为patch信息，app根据当前的版本信息去请求相应的文件，即可获得patch信息，去下载相应的文件（当前我们app使用的方案）。 总结1.热修复不用发版本就可以及时的修复bug;2.使用轻量级Andfix，可以在应用不重启的情况下达到修复bug的目的，但是功能比较简单，只能更改简单的方法，不能添加类，更不能更改资源等等3.loadPatch()和addPatch(String path)一定要在主线程中调用，要不然可能出现崩溃问题和不能立即生效的问题（可能是部分机型）！4.建议使用0.4.0版本，因为最新的0.5.0版本很不稳定，兼容性也不是特别好！ 参考： https://github.com/alibaba/AndFix http://www.chinaz.com/news/2016/0912/579753.shtml","categories":[{"name":"Android","slug":"Android","permalink":"http://huanglei365.com/categories/Android/"}],"tags":[{"name":"Hotfix","slug":"Hotfix","permalink":"http://huanglei365.com/tags/Hotfix/"},{"name":"Andfix","slug":"Andfix","permalink":"http://huanglei365.com/tags/Andfix/"}]},{"title":"2016年度总结","slug":"2016年度总结","date":"2017-01-25T04:01:34.000Z","updated":"2017-01-25T04:03:32.148Z","comments":true,"path":"2017/01/25/2016年度总结/","link":"","permalink":"http://huanglei365.com/2017/01/25/2016年度总结/","excerpt":"又到了一年的年尾，转眼间离开大学校园已然两年多了，这两年多真的是感慨颇多，有的人买了房子，也有的人结了婚生了孩子，更有的人还在为了一份稳定的工作而努力！现在突然想提笔记下这已经过去的日子，同时也思考一下未来，给自己的未来一个规划！毕业后基本就告别了写作，现在提起笔来，有种突然要转行的不适感，但还是要硬着头皮写下去！","text":"又到了一年的年尾，转眼间离开大学校园已然两年多了，这两年多真的是感慨颇多，有的人买了房子，也有的人结了婚生了孩子，更有的人还在为了一份稳定的工作而努力！现在突然想提笔记下这已经过去的日子，同时也思考一下未来，给自己的未来一个规划！毕业后基本就告别了写作，现在提起笔来，有种突然要转行的不适感，但还是要硬着头皮写下去！ 工作 毕业两年半，可以分为在合肥的一年和在上海的一年半！两座城市，两份工作给了我完成不同的体验！ 合肥：班车－＞吃早餐－＞等电梯－＞工作－＞下班，这样的生活没有变化！合肥生活的节奏很慢，很少有人听到公司同事又出去创业或者其他之类的！ 上海：地铁－＞工作－＞可能会加班，可能一周到两周必须要发布一个版本！明显感觉到生活节奏快了很多，公司也有同事出去创立自己的公司等等，感觉日子有了变化！ 这两种工作方式给我了不同的收获，在合肥，工作比较慢，每个同事负责各自的部分，这种方式让我对自己负责的部分比较熟悉而对项目其他部分就有点陌生！写三天的代码，至少需要２－３次的代码review才能发布等等，这样的方式造成了没有大局观同时也养成了代码洁癖和对代码的设计有更高的要求！在上海，由于竞品激烈的竞争，写一周的代码，基本来不及review，马上就要测试发布！不再是每个人负责一部分，而是每个人都会接触所有的功能模块．虽然你只有两年经验，只要你足够优秀，很可能就给你开发整个完成新项目！我有幸从零开始写一个项目，从中得到了很多，不仅仅是写代码，实现功能！还要考虑如果让其他维护的同事更容易维护和扩展你写的代码，自己也有了大局观！对自己的工作有了更多的思考，你要思考这个需求合理吗？对用户友好吗？符合我们产品的风格吗？ 总之，两年时间，不同的工作，有了不同的收获，感谢所有的同事！ 学习 直到写这篇文章之前，我的学习方式都是从网上查需要的资料，比如Android开发，就是在网上学习的，没有完整的看过任何关于Android教学方面的书籍！为什么是这样？主要原因是我作为一个it从业人员，自认为自己对互联网很了解，不需要任务纸质的书籍资料就可以通过网络学习到任何的东西，但是现在我改变了自己现在幼稚的想法，看书籍跟读网上的资料很大的区别，但从质量来说就高出很多，还有一个很重要的原因是书籍一般来说比较系统，可以完整的了解知识！我会在计划里面列2017年的读书列表，同时也会坚持不懈的执行下去！ 变化 有了更明确的目标！ 思想上有了改变！ 感悟 不要吝啬于为知识付费； 演讲、沟通和写作能力，真的可以做到你练得越多，就做得越好； 专注于一件事情； 计划 读书计划，以下是书单：《成为技术领导者》《构建之法》《移动App性能评测与优化》《高性能Android应用开发》《Android高级进阶》《深入理解Java虚拟机》； 坚持每周至少一篇技术博客；","categories":[{"name":"总结","slug":"总结","permalink":"http://huanglei365.com/categories/总结/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"http://huanglei365.com/tags/年度总结/"},{"name":"总结","slug":"总结","permalink":"http://huanglei365.com/tags/总结/"}]},{"title":"带你彻底理解java中的==、equal、hashCode","slug":"带你彻底理解java中的-、equal、hashCode","date":"2017-01-24T01:29:49.000Z","updated":"2017-01-24T06:52:35.730Z","comments":true,"path":"2017/01/24/带你彻底理解java中的-、equal、hashCode/","link":"","permalink":"http://huanglei365.com/2017/01/24/带你彻底理解java中的-、equal、hashCode/","excerpt":"相信很多刚入门的甚至有Java开发工程师对==、equals和为什么重写equal方法一定要重写hashCode方法都有很多的疑惑，今天就带你彻底理解==和equals的区别以及重写hashCode方法的意义！ ==的含义Java官网教程对==的描述如下： Checks if the values of two operands are equal or not, if yes then condition becomes true. ==是一个二元操作符，比较两个操作数是否相等！现在的关键就是理解操作数，下面我们通过一个例子说明一下不同类型的操作数的比较结果：","text":"相信很多刚入门的甚至有Java开发工程师对==、equals和为什么重写equal方法一定要重写hashCode方法都有很多的疑惑，今天就带你彻底理解==和equals的区别以及重写hashCode方法的意义！ ==的含义Java官网教程对==的描述如下： Checks if the values of two operands are equal or not, if yes then condition becomes true. ==是一个二元操作符，比较两个操作数是否相等！现在的关键就是理解操作数，下面我们通过一个例子说明一下不同类型的操作数的比较结果：123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // 基本数据类型 int a = 1, b = 1; System.out.println(a == b); // 基本类型的包装类型（属于引用） Integer aS = 1, bS = 1; System.out.println(aS == bS); Integer aB = 234, bB = 234; System.out.println(aB == bB); // 引用类型 Test testa = new Test(); Test testb = new Test(); System.out.println(testa == testb); &#125; public static class Test &#123; &#125; /*输出结果如下： * true * true * false * false */ 关于输出结果，现在很多人可能还在疑惑，那我们就给大家解释一下为什么是上面的输出结果！==的含义是比较两个操作数的Memory Refrence，翻译过来就是内存引用，即两个引用是否都指向了同一个对象(可以这么理解)！我们知道1.基本类型变量和对象的引用变量都在函数的栈内存中分配，注意栈有一个很重要的特殊性，就是存在栈中的数据可以共享，2.new创建的对象和数组以及对象的实例变量！想了解更多请参见java内存类型及不同数据类型的存储，有了这样的知识上面的结果是不是就好理解一点！第一行输出我们可能都可以理解，共享了同一个数据，但是第二行和第三行就疑惑了？为啥输出结果不相同呢？原因是Integer使用了缓存机制(-128-127都是同一个对象，除非手动new对象，想了解更多请参见java Integer类的缓存)，关于最后一行输出结果应该也很容易理解(testa,testb不是同一个对象)！我们可以使用System.identityHashCode()(此方法返回Object.hashCode，无论有没有重写hashCode方法)方法进行hash验证！ equals的理解以及重写规则网上的说法一般都是说equals比较的是内容，那我们该如何理解内容的含义呐！下面我们从源码的角度更深入的理解！想要理解equals方法，必须知道在哪里实现了这个方法！我们知道，equals方法是Object对象的方法，Object对象默认是所有对象的父类，可以被其子类重写！那我们现看一下Object是如何实现的，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Indicates whether some other object is &quot;equal to&quot; this one. * &lt;p&gt; * The &#123;@code equals&#125; method implements an equivalence relation * on non-null object references: * &lt;ul&gt; * &lt;li&gt;It is &lt;i&gt;reflexive&lt;/i&gt;: for any non-null reference value * &#123;@code x&#125;, &#123;@code x.equals(x)&#125; should return * &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;symmetric&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, &#123;@code x.equals(y)&#125; * should return &#123;@code true&#125; if and only if * &#123;@code y.equals(x)&#125; returns &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;transitive&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125;, &#123;@code y&#125;, and &#123;@code z&#125;, if * &#123;@code x.equals(y)&#125; returns &#123;@code true&#125; and * &#123;@code y.equals(z)&#125; returns &#123;@code true&#125;, then * &#123;@code x.equals(z)&#125; should return &#123;@code true&#125;. * &lt;li&gt;It is &lt;i&gt;consistent&lt;/i&gt;: for any non-null reference values * &#123;@code x&#125; and &#123;@code y&#125;, multiple invocations of * &#123;@code x.equals(y)&#125; consistently return &#123;@code true&#125; * or consistently return &#123;@code false&#125;, provided no * information used in &#123;@code equals&#125; comparisons on the * objects is modified. * &lt;li&gt;For any non-null reference value &#123;@code x&#125;, * &#123;@code x.equals(null)&#125; should return &#123;@code false&#125;. * &lt;/ul&gt; * &lt;p&gt; * The &#123;@code equals&#125; method for class &#123;@code Object&#125; implements * the most discriminating possible equivalence relation on objects; * that is, for any non-null reference values &#123;@code x&#125; and * &#123;@code y&#125;, this method returns &#123;@code true&#125; if and only * if &#123;@code x&#125; and &#123;@code y&#125; refer to the same object * (&#123;@code x == y&#125; has the value &#123;@code true&#125;). * &lt;p&gt; * Note that it is generally necessary to override the &#123;@code hashCode&#125; * method whenever this method is overridden, so as to maintain the * general contract for the &#123;@code hashCode&#125; method, which states * that equal objects must have equal hash codes. * * @param obj the reference object with which to compare. * @return &#123;@code true&#125; if this object is the same as the obj * argument; &#123;@code false&#125; otherwise. * @see #hashCode() * @see java.util.HashMap */ public boolean equals(Object obj) &#123; return (this == obj); &#125; 从源码可知，如果子类没有重写equals方法，那么equals和==号的含义一样！那如果我们重写了方法就代表我们定义了一组代表两个对象相等的规则！这样是不是就代表我们就可以随意定义规则了呢？当然了，如果你想这样做也可以(不考虑各种后果，请自行百度)！系统建议我们重写equals必须满足一定的规则，并且必要的话，要重写hashCode方法，否则两个等价对象可能得到不同的hashCode,这在集合框架中使用可能产生严重后果！一般重写equals需要满足以下规则： 1．自反性：对于任意的非空引用值x，x.equals(x)一定为true 2． 对称性：对于任意的引用值x 和 y，当x.equals(y)返回true，y.equals(x)也一定返回true3． 传递性：对于任意的引用值x、y和ｚ，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也一定返 回 true 4． 一致性：对于任意的引用值x 和 y，如果用于equals比较的对象信息没有被修改， 多次调用x.equals(y)要么一致地返回true，要么一致地返回false5． 非空性：对于任意的非空引用值x，x.equals(null)一定返回false下面是重写equal的一个例子，大家可以思考下面的写法是怎么满足以上５个条件的： 1234567891011121314151617181920212223242526272829303132333435363738public class Book &#123; private String name; private int price; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; @Override public boolean equals(Object o) &#123; if (o == null || !(o instanceof Book)) &#123; return false; &#125; if (getName() != null &amp;&amp; getName().equals(((Book) o).getName()) &amp;&amp; getPrice() == ((Book) o).getPrice()) &#123; return true; &#125; return super.equals(o); &#125; @Override public int hashCode() &#123; int hashCode = getName() == null ? 0 : getName().hashCode(); return hashCode + price; &#125; &#125; 关于重写hashCode函数的意义上面我们已经强调了如果有必要一定要重写hashCode但没有说明原因，这一节我们就通过源码来深入理解hashCode的意义！Java中的集合（Collection）有两类，一类是List，再有一类是Set．你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复．那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了．也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率．于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了．哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。如果详细讲解哈希算法，那需要更多的文章篇幅，我在这里就不介绍了。初学者可以这样理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）．这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上．如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址．所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。所以，Java对于eqauls方法和hashCode方法是这样规定的：1、如果两个对象相同，那么它们的hashCode值一定要相同；2、如果两个对象的hashCode相同，它们并不一定相同上面说的对象相同指的是用eqauls方法比较。通过以上我们可以知道，重写hashCode方法，让相同的对象hash值相同，不同对象hash值不同(减少hash冲突)，这样可以大大的提高Java中使用hash表实现的数据结构的插入和查找效率！ 总结==：比较两个对象的内存地址是否一样equals：通过自定义规则，比较两个对象的内容是否相等hashCode：重写equals时，之所以要重写次此方法，主要是为了与equals保持相同的结果，进而减少hash冲突，提高hash表的插入和查找效率！","categories":[{"name":"Java","slug":"Java","permalink":"http://huanglei365.com/categories/Java/"}],"tags":[{"name":"Equal","slug":"Equal","permalink":"http://huanglei365.com/tags/Equal/"},{"name":"Hash","slug":"Hash","permalink":"http://huanglei365.com/tags/Hash/"}]},{"title":"Android WebView Cookie机制详解","slug":"Android-WebView-Cookie机制详解","date":"2017-01-23T09:18:03.000Z","updated":"2017-01-24T02:50:28.715Z","comments":true,"path":"2017/01/23/Android-WebView-Cookie机制详解/","link":"","permalink":"http://huanglei365.com/2017/01/23/Android-WebView-Cookie机制详解/","excerpt":"随着H5在移动端的体验越来越好，越来越多的Android App开始采用Native+H5进行混合开发！极大的提高了开发效率！最近公司在做一个新闻阅读的模块，由于我们没有资源，所以选择了第三方Url接入方式．在开发的过程中，需要用到WebView Cookie的设置！下面详细的说明WebView Cookie机制．","text":"随着H5在移动端的体验越来越好，越来越多的Android App开始采用Native+H5进行混合开发！极大的提高了开发效率！最近公司在做一个新闻阅读的模块，由于我们没有资源，所以选择了第三方Url接入方式．在开发的过程中，需要用到WebView Cookie的设置！下面详细的说明WebView Cookie机制． Cookie机制? 众所周知，HTTP协议是一种无状态的协议，一旦数据交换完成，客户端与服务端的连接就会关闭，如果需要再次交换数据，就需要再次联立连接，导致服务端无法跟踪上次的会话！Cookie机制是一种会话跟踪的技术，通过在客户端记录信息用以确定用户身份！ Cookie其实就是服务器用于确认客户端身份给客户端的信息，下次客户端请求时带上Cookie信息，服务器就可以根据Cookie确定用户信息进而进行个性化处理！ Cookie的属性包括Key，Value，MaxAge，Path等等，关于具体的属性信息请参考：[Android HttpCookie信息][1] 注意：为了保证用户的信息安全，Cookie是不可跨域名的！Cookie在客户端是由浏览器管理的，访问baidu.com的域名不会携带google.com的Cookie! 如何给Android中的WebView设置Cookie信息？ 涉及到的主要类及介绍其中主要涉及到CookieSyncManager和CookieManager两个类！CookieSyncManager：顾名思义就是浏览器Cookie在内存和永久性存储器之间的同步类（The CookieSyncManager is used to synchronize the browser cookie store between RAM and permanent storage），其中包括startSync(),stopSync(),sync()(强制同步)等方法；（注意：Api 21已废除，通过CookieManager进行自动同步）CookieManager：管理WebView Cookie的类，其中包括setCookie(),getCookie()等等方法． 获取Cookie和给WebView设置Cookie获取Cookie比较简单，直接调用CookieManager.getInstance().getCookie(url)即可获得；设置Cookie在webView实例对象调用loadUrl方式之前调用如下函数即可． 1234567891011 public static void syncCookie(Context context, String url, HashMap&lt;String, String&gt; cookies) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); Iterator iterator = cookies.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); cookieManager.setCookie(url, entry.getValue() + &quot;=&quot; + entry.getKey()); &#125;&#125; 使用场景主要使用在，服务端需要客户端的数据以确定客户身份的情况！比如：登录同步(我们通过HttpUrlConnection获得的Cookie设置给WebView就可以实现登录同步了)等等，还有许多应用需要你去发掘…","categories":[{"name":"Android","slug":"Android","permalink":"http://huanglei365.com/categories/Android/"}],"tags":[{"name":"WebView","slug":"WebView","permalink":"http://huanglei365.com/tags/WebView/"},{"name":"Cookie","slug":"Cookie","permalink":"http://huanglei365.com/tags/Cookie/"}]},{"title":"ubuntu上构建简单的基于http的文件共享服务","slug":"ubuntu上构建简单的基于http的文件共享服务","date":"2017-01-23T03:41:49.000Z","updated":"2017-01-24T02:50:33.451Z","comments":true,"path":"2017/01/23/ubuntu上构建简单的基于http的文件共享服务/","link":"","permalink":"http://huanglei365.com/2017/01/23/ubuntu上构建简单的基于http的文件共享服务/","excerpt":"下面的方法教你如何用简单的几行命令就可以在ubuntu上构建一个http文件共享服务。 首先，你需要安装一个脚本，你只要执行以下指令即可：","text":"下面的方法教你如何用简单的几行命令就可以在ubuntu上构建一个http文件共享服务。 首先，你需要安装一个脚本，你只要执行以下指令即可： 1．下载脚本文件： sudo wget -O /usr/local/bin/subdirs http://github.com/singpolyma/singpolyma/raw/master/scripts/subdirs 2．给脚本文件增加执行权限： sudo chmod +X /usr/local/bin/subdirs３．然后，你需要安装wefs http server，执行以下指令即可install： sudo apt-get install webfs４．最后，你只要简单的配置一下，简单的http文件共享服务就构建完成了： 打开/etc/webfsd.conf文件并编辑配置web_root、web_port，我相信大家都知道这两个的含义。 现在，我们的http服务已经构建完成，就让我们开始使用吧。1.重启wefs 服务：sudo /etc/init.d/wefs restart2.在浏览器中输入：http://www.{your ip address:port}.com/，开始访问吧！","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://huanglei365.com/categories/Ubuntu/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://huanglei365.com/tags/Http/"}]},{"title":" android 跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果","slug":"android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果","date":"2017-01-23T02:38:59.000Z","updated":"2017-01-24T02:50:30.731Z","comments":true,"path":"2017/01/23/android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果/","link":"","permalink":"http://huanglei365.com/2017/01/23/android-跑马灯效果的基本实现以及自定义实现一个界面多个跑马灯效果/","excerpt":"前言 我相信很多人都在实现过Android的跑马灯效果，肯定也有很多人说一个界面不能实现多个跑马灯效果，其实我们通过很简单的方式就可以实现，下面介绍一个实现方式。 单个跑马灯实现","text":"前言 我相信很多人都在实现过Android的跑马灯效果，肯定也有很多人说一个界面不能实现多个跑马灯效果，其实我们通过很简单的方式就可以实现，下面介绍一个实现方式。 单个跑马灯实现 1234567891011&lt;TextView android:layout_width=\"100px\" android:layout_height=\"wrap_content\" android:ellipsize=\"marquee\" android:focusable=\"true\" android:singleLine=\"true\" android:marqueeRepeatLimit=\"marquee_forever\" android:focusableInTouchMode=\"true\" android:scrollHorizontally=\"true\" android:text=\"马灯效果\"&gt; &lt;/TextView&gt; 备注： ellipsize=”marquee” :跑马灯效果 marqueeRepeatLimit:循环的次数 singleLine:如果不设置成单行，跑马灯也就没有了意义 至于为什么focusable设置为true，那是因为只有获得了焦点才能出现跑马灯的效果 更多的含义请参跑马灯效果的总结 一个界面多个跑马灯效果实现 想要实现一个界面多个跑马灯，就要现了解系统是如何实现以及在什么情况下会显示跑马灯效果．我们在TextView中发现以下源码（Api 23）： 12345678910111213141516171819202122232425private void startMarquee() &#123; // Do not ellipsize EditText if (getKeyListener() != null) return; if (compressText(getWidth() - getCompoundPaddingLeft() - getCompoundPaddingRight())) &#123; return; &#125; if ((mMarquee == null || mMarquee.isStopped()) &amp;&amp; (isFocused() || isSelected()) &amp;&amp; getLineCount() == 1 &amp;&amp; canMarquee()) &#123; if (mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123; mMarqueeFadeMode = MARQUEE_FADE_SWITCH_SHOW_FADE; final Layout tmp = mLayout; mLayout = mSavedMarqueeModeLayout; mSavedMarqueeModeLayout = tmp; setHorizontalFadingEdgeEnabled(true); requestLayout(); invalidate(); &#125; if (mMarquee == null) mMarquee = new Marquee(this); mMarquee.start(mMarqueeRepeatLimit); &#125; &#125; 由源代码（isFocused() || isSelected()）可知只有当TextView拥有焦点或者是选中状态是才会有跑马灯效果，但是Android的焦点机制只能有一个View获得焦点．我们怎么才能让多个View处于获得焦点或者被选中状态呢？我们可以通过重写TextView的isFocused()或者isSelected()方法来告诉系统此View已经获得焦点！下面是代码实现： import android.content.Context;import android.text.TextUtils;import android.util.AttributeSet;import android.widget.TextView; 12345678910111213141516171819202122232425262728293031323334353637public class MarqueeTextView extends TextView &#123; public MarqueeTextView(Context context) &#123; this(context, null); &#125; public MarqueeTextView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MarqueeTextView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; setEllipsize(TextUtils.TruncateAt.MARQUEE); setMarqueeRepeatLimit(-1); setSingleLine(); &#125; /* * 不建议重写isFocused()方法． * 经过测试发现如果有多个跑马灯效果的界面还有EditText,在某些机型上会由于焦点问题弹出输入法键盘． */ /* @Override public boolean isFocused() &#123; return true; &#125;*/ @Override public boolean isSelected() &#123; return true; &#125;&#125; 用法只要在layout文件中添加如下代码：123&lt;＊.MarqueeTextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; 用法也比以前简单了很多，不用如下乱七八糟的设置： 123456 android:focusable android:ellipsize=”marquee” android:focusable=”true” android:singleLine=”true” android:marqueeRepeatLimit=”marquee_forever” android:focusableInTouchMode=”true” 这样就完美的解决了我们的问题，是不是很简单？","categories":[{"name":"Android","slug":"Android","permalink":"http://huanglei365.com/categories/Android/"}],"tags":[{"name":"TextView","slug":"TextView","permalink":"http://huanglei365.com/tags/TextView/"},{"name":"Marquee","slug":"Marquee","permalink":"http://huanglei365.com/tags/Marquee/"}]}]}